function checksProbFormate(sProb)
%CHECKSPROBFORMATE This functions checks whether the formate of the struct 
% sProb fits the setting for the modularized ALADIN solver

% check formates
% locFuns
assert(isstruct(sProb.locFuns), ...
    'the field sProb.locFuns is supposed to be a struct');
assert(iscell(sProb.locFuns.ffi), ...
    'the field sProb.loc.ffi is supposed to be a cell');
assert(iscell(sProb.locFuns.ggi), ...
    'the field sProb.loc.ggi is supposed to be a cell');
assert(iscell(sProb.locFuns.hhi), ...
    'the field sProb.loc.hhi is suposed to be a cell');
assert(iscell(sPrb.locFuns.dims), ...
    'the field sProb.locFuns.dims is supposed to be handed over via a struct');
assert(isa(sProb.locFuns.ffi{1}, 'function_handle'), ...
    'the objective functions inside sProb.locFuns.ffi{i} are supposed to be matlab function handles');
assert(isa(sProb.locFuns.ggi{1}, 'function_handle'), ...
    'the constraint function inside sProb.locFuns.ggi{i} are supposed to be matlab function handles');
assert(isa(sProb.locFuns.hhi{1}, 'function_handle'), ...
    'the constraint function inside sProb.locFuns.hhi{i} are supposed to be matlab function handles');
assert(isstruct(sProb.locFuns.dims{1}), ...
    'sProb.locFuns.dims is supposed to be a struct');

% sens
assert(isstruct(sProb.sens), ...
    'the field sProb.sens is supposed to be a struct');
assert(iscell(sProb.sens.gg), ...
    'the field sProb.sens.gg is supposed to be a cell array');
assert(iscell(sProb.sens.JJac), ...
    'the field sProb.sens.JJac is supposed to be a cell array');
assert(iscell(sProb.sens.HH), ...
    'the field sProb.sens.HH is supposed to be a cell array');
assert (isa(sProb.sens.gg{1}, 'function_handle'), ...
    'the entries of sProb.sens.gg{i} are supposed to be function handles');
assert (isa(sProb.sens.JJac{1}, 'function_handle'), ...
    'the entries of sProb.sens.JJac{i} are supposed to be function handles');
assert (isa(sProb.sens.HH{1}, 'function_handle'), ...
    'the entries of sProb.sens.HH{i} are supposed to be function handles');

% nnlp
assert(iscell(sProb.nnlp), ...
    'to hand over the local nlp solver, the filed sProb.nnlp, needs to be a cell array');
assert(isstring(sProb.nnlp{1}.name), ...
    'the fields sProb.nnlp{i}.name are supposed to be strings');
assert(isa(sProb.nnlp{1}.solve_nlp, 'function_handle'), ... 
    'the nlp solver needs to be handend over as a function handle');
assert( (isstruct(sProb.nnlp{1}.specs) || isempty(sProb.nnlp{1}.specs)), ...
    'the specification of the nnlp solver should either be a struct or empty');

% zz0
assert(iscell(sProb.zz0), ...
    'the initial conditions of the local solvers need to be handed over via a cell');
assert(isvector(sProb.zz0{1}), ...
    'the entries of sProb.zz0{i} should be vectors');

% llbx
assert(iscell(sProb.llbx), ...
    'the lower bounds of the local problems need to be handed over as a cell');
assert(isvector(sProb.llbx{1}), ...
    'the entries of sProb.llbx{i} should be vectors');

% uubx
assert(iscell(sProb.uubx), ...
    'the lower bounds of the local problems need to be handed over as a cell');
assert(isvector(sProb.uubx{1}), ...
    'the entries of sProb.llbx{i} should be vectors');

% AA
assert(iscell(sProb.AA), ...
    'the entity of the coupling matrices sProb.AA need to be handed over in a cell');
assert(ismatrix(sProb.AA{1}), ...
    'the coupling matrices sProb.AA{i} need to be handed over in a cell');

% b
assert(isvector(sProb.b), ...
    'the right hand sde of the consensus constraints needs to be a vector');

% lam0
assert(isvector(sProb.lam0), ...
    'initial condition for multipliers of consenss constraints needs to be a vector');

% specs
assert(isstruct(sProb.specs)||isempty(sProb.specs), ...
    'specifications sProb.specs for ALADIN need to be either a struct or empty');

% Mfun
assert(isa(sProb.Mfun, 'function_handle'), ...
    'the merit function needs to be handed over as a function handle');

end

